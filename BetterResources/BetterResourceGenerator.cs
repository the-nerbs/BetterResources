using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Resources;
using System.Collections;
using System.ComponentModel.Design;

namespace BetterResources
{
    /// <summary>
    /// Provides the ability to generate a strongly-typed resource accessor class similar to the
    /// ones generated by the default Microsoft Visual Studio tools, but with methods to format
    /// the strings.
    /// </summary>
    public class BetterResourceGenerator
    {
        /// <summary>
        /// The default extension of the generated file.
        /// </summary>
        public const string CodeFileExtension = ".Designer.cs";


        /// <summary>
        /// Gets or sets the namespace of the generated class.
        /// </summary>
        public string Namespace { get; set; }

        /// <summary>
        /// Gets or sets the name of the generated class.
        /// </summary>
        public string ClassName { get; set; }

        /// <summary>
        /// Gets or sets a value indicating if the generated class is public or internal.
        /// </summary>
        public bool IsPublic { get; set; }


        /// <summary>
        /// Generated a code file from a RESX file.
        /// </summary>
        /// <param name="path">The path to the RESX file to generate from.</param>
        /// <param name="reporter">An object used to communicate diagnostics back to the caller.</param>
        /// <returns>The content of the generated code file.</returns>
        public string RunOnFile(string path, IDiagnosticReporter reporter)
        {
            using (var reader = new ResXResourceReader(path))
            {
                return GenerateCodeForResx(reader, reporter);
            }
        }

        /// <summary>
        /// Generated a code file from a RESX file.
        /// </summary>
        /// <param name="resxContent">The content of the RESX file to generate from.</param>
        /// <param name="reporter">An object used to communicate diagnostics back to the caller.</param>
        /// <returns>The content of the generated code file.</returns>
        public string RunOnContent(string resxContent, IDiagnosticReporter reporter)
        {
            using (var reader = ResXResourceReader.FromFileContents(resxContent))
            {
                return GenerateCodeForResx(reader, reporter);
            }
        }

        /// <summary>
        /// Generates a code file from the given RESX reader.
        /// </summary>
        /// <param name="reader">The resx reader the generated class is based on.</param>
        /// <param name="reporter">An object used to communicate diagnostics back to the caller.</param>
        /// <returns>The content of the generated code file.</returns>
        private string GenerateCodeForResx(ResXResourceReader reader, IDiagnosticReporter reporter)
        {
            if (reporter == null)
            {
                reporter = new ConsoleReporter();
            }

            ResourceTemplate template = BuildTemplate(reader, reporter);

            return template.TransformText();
        }


        /// <summary>
        /// Builds a code file template from the given RESX reader.
        /// </summary>
        /// <param name="reader">The resx reader the generated class is based on.</param>
        /// <param name="reporter">An object used to communicate diagnostics back to the caller.</param>
        /// <param name="typeResolver">An object used to resolve types by their name.</param>
        /// <returns>The completed code file template.</returns>
        private ResourceTemplate BuildTemplate(ResXResourceReader reader, IDiagnosticReporter reporter, ITypeResolutionService typeResolver = null)
        {
            var template = new ResourceTemplate
            {
                ClassName = ClassName,
                Namespace = Namespace,
                IsPublic = IsPublic,
                ResourceName = Namespace + "." + ClassName,
            };

            reader.UseResXDataNodes = true;
            foreach (DictionaryEntry entry in reader)
            {
                if (entry.Value is ResXDataNode resxNode)
                {
                    string typeName = resxNode.GetValueTypeName(typeResolver);

                    bool isString = (typeName?.Contains(typeof(string).FullName) == true);

                    if (isString
                        && resxNode.FileRef == null)
                    {
                        string str = (string)resxNode.GetValue(typeResolver);
                        template.StringResources.Add(
                            new StringResource(resxNode.Name, str, resxNode.Comment)
                        );
                    }
                    else if (isString)
                    {
                        template.TextFileResources.Add(
                            new TextFileResource(resxNode.Name, resxNode.Comment)
                        );
                    }
                    else
                    {
                        string fullTypeName = typeName.Substring(0, typeName.IndexOf(','));

                        if (fullTypeName == typeof(MemoryStream).FullName)
                        {
                            template.StreamResources.Add(
                                new StreamResource(resxNode.Name, resxNode.Comment)
                            );
                        }
                        else
                        {
                            template.ObjectResources.Add(
                                new ObjectResource(resxNode.Name, fullTypeName, resxNode.Comment)
                            );
                        }
                    }
                }
            }

            return template;
        }
    }
}
